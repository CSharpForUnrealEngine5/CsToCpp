namespace GameFramework;
using CSharpToCpp.Utilities;
[CppInclude("Components/SynthComponent.h")]
public partial class USynthComponent : USceneComponent {
	public static UClass StaticClass() {return default;}
	///<summary>Starts the synth generating audio.</summary>
	public void Start() {}
	///<summary>Stops the synth generating audio.</summary>
	public void Stop() {}
	///<summary>Returns true if this component is currently playing.</summary>
	public bool IsPlaying() { return default; }
	///<summary>Set a new volume multiplier</summary>
	public void SetVolumeMultiplier(float VolumeMultiplier) {}
	///<summary>Sets how much audio the sound should send to the given submix.</summary>
	public void SetSubmixSend(USoundSubmixBase Submix,float SendLevel) {}
	///<summary>Sets how much audio the sound should send to the given SourceBus (pre effect).</summary>
	public void SetSourceBusSendPreEffect(USoundSourceBus SoundSourceBus,float SourceBusSendLevel) {}
	///<summary>Sets how much audio the sound should send to the given SourceBus (post effect).</summary>
	public void SetSourceBusSendPostEffect(USoundSourceBus SoundSourceBus,float SourceBusSendLevel) {}
	///<summary>Sets how much audio the sound should send to the given AudioBus (pre effect).</summary>
	public void SetAudioBusSendPreEffect(UAudioBus AudioBus,float AudioBusSendLevel) {}
	///<summary>Sets how much audio the sound should send to the given AudioBus (post effect).</summary>
	public void SetAudioBusSendPostEffect(UAudioBus AudioBus,float AudioBusSendLevel) {}
	///<summary>Sets whether or not the low pass filter is enabled on the audio component.</summary>
	public void SetLowPassFilterEnabled(bool InLowPassFilterEnabled) {}
	///<summary>Sets lowpass filter frequency of the audio component.</summary>
	public virtual void SetLowPassFilterFrequency(float InLowPassFilterFrequency) {}
	///<summary>Sets whether or not the synth component outputs its audio to any source or audio buses.</summary>
	public void SetOutputToBusOnly(bool bInOutputToBusOnly) {}
	///<summary>This function allows designers to call Play on an Audio Component instance while applying a volume curve over time.</summary>
	public void FadeIn(float FadeInDuration,float FadeVolumeLevel/*=1.0f*/,float StartTime/*=0.0f*/,EAudioFaderCurve FadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>This function allows designers to call a delayed Stop on an Audio Component instance while applying a</summary>
	public void FadeOut(float FadeOutDuration,float FadeVolumeLevel,EAudioFaderCurve FadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>This function allows designers to trigger an adjustment to the sound instanceâ€™s playback Volume with options for smoothly applying a curve over time.</summary>
	public void AdjustVolume(float AdjustVolumeDuration,float AdjustVolumeLevel,EAudioFaderCurve FadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>Sets the routing for one of the given Synth component&#39;s Modulation Destinations.</summary>
	public void SetModulationRouting(TSet<USoundModulatorBase> Modulators,EModulationDestination Destination,EModulationRouting RoutingMethod/*=EModulationRouting.Inherit*/) {}
	///<summary>Gets the set of currently active modulators for a given Modulation Destination.</summary>
	public TSet<USoundModulatorBase> GetModulators(EModulationDestination Destination) { return default; }
	///<summary>Auto destroy this component on completion</summary>
	public bool bAutoDestroy;
	///<summary>Stop sound when owner is destroyed</summary>
	public bool bStopWhenOwnerDestroyed;
	///<summary>Is this audio component allowed to be spatialized?</summary>
	public bool bAllowSpatialization;
	///<summary>Should the Attenuation Settings asset be used (false) or should the properties set directly on the component be used for attenuation properties</summary>
	public bool bOverrideAttenuation;
	///<summary>Whether or not to only send this audio&#39;s output to a bus. If true, this sound will not be audible except through bus sends.</summary>
	public bool bOutputToBusOnly_DEPRECATED;
	///<summary>Whether or not to enable sending this audio&#39;s output to buses.</summary>
	public bool bEnableBusSends;
	///<summary>If enabled, sound will route to the Master Submix by default or to the Base Submix if defined. If disabled, sound will route ONLY to the Submix Sends and/or Bus Sends</summary>
	public bool bEnableBaseSubmix;
	///<summary>Whether or not to enable Submix Sends other than the Base Submix.</summary>
	public bool bEnableSubmixSends;
	///<summary>If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component</summary>
	public USoundAttenuation AttenuationSettings;
	///<summary>If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component</summary>
	public FSoundAttenuationSettings AttenuationOverrides;
	///<summary>What sound concurrency to use for sounds generated by this audio component</summary>
	public USoundConcurrency ConcurrencySettings_DEPRECATED;
	///<summary>What sound concurrency to use for sounds generated by this audio component</summary>
	public TSet<USoundConcurrency> ConcurrencySet;
	///<summary>ModulationRouting</summary>
	public FSoundModulationDefaultRoutingSettings ModulationRouting;
	///<summary>Sound class this sound belongs to</summary>
	public USoundClass SoundClass;
	///<summary>The source effect chain to use for this sound.</summary>
	public USoundEffectSourcePresetChain SourceEffectChain;
	///<summary>Submix this sound belongs to</summary>
	public USoundSubmixBase SoundSubmix;
	///<summary>An array of submix sends. Audio from this sound will send a portion of its audio to these effects.</summary>
	public TArray<FSoundSubmixSendInfo> SoundSubmixSends;
	///<summary>This sound will send its audio output to this list of buses if there are bus instances playing after source effects are processed.</summary>
	public TArray<FSoundSourceBusSendInfo> BusSends;
	///<summary>This sound will send its audio output to this list of buses if there are bus instances playing before source effects are processed.</summary>
	public TArray<FSoundSourceBusSendInfo> PreEffectBusSends;
	///<summary>Whether or not this sound plays when the game is paused in the UI</summary>
	public bool bIsUISound;
	///<summary>Whether or not this synth is playing as a preview sound</summary>
	public bool bIsPreviewSound;
	///<summary>The attack time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the</summary>
	public int EnvelopeFollowerAttackTime;
	///<summary>The release time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the</summary>
	public int EnvelopeFollowerReleaseTime;
	///<summary>OnAudioEnvelopeValue</summary>
	public FOnSynthEnvelopeValue OnAudioEnvelopeValue;
	///<summary>Synth</summary>
	public USynthSound Synth;
	///<summary>AudioComponent</summary>
	public UAudioComponent AudioComponent;
}
