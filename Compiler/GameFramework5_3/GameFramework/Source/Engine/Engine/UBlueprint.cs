namespace GameFramework;
using CSharpToCpp.Utilities;
///<summary>Blueprints are special assets that provide an intuitive, node-based interface that can be used to create new types of Actors</summary>
[CppInclude("Engine/Blueprint.h")]
public partial class UBlueprint : UBlueprintCore {
	public static UClass StaticClass() {return default;}
	///<summary>Pointer to the parent class that the generated class should derive from. This *can* be null under rare circumstances,</summary>
	public UClass ParentClass;
	///<summary>The type of this blueprint</summary>
	public EBlueprintType BlueprintType;
	///<summary>Whether or not this blueprint should recompile itself on load</summary>
	public bool bRecompileOnLoad;
	///<summary>When the class generated by this blueprint is loaded, it will be recompiled the first time.  After that initial recompile, subsequent loads will skip the regeneration step</summary>
	public bool bHasBeenRegenerated;
	///<summary>State flag to indicate whether or not the Blueprint is currently being regenerated on load</summary>
	public bool bIsRegeneratingOnLoad;
	///<summary>The blueprint is currently compiled</summary>
	public bool bBeingCompiled;
	///<summary>Whether or not this blueprint is newly created, and hasn&#39;t been opened in an editor yet</summary>
	public bool bIsNewlyCreated;
	///<summary>Whether to force opening the full (non data-only) editor for this blueprint.</summary>
	public bool bForceFullEditor;
	///<summary>bQueuedForCompilation</summary>
	public bool bQueuedForCompilation;
	///<summary>whether or not you want to continuously rerun the construction script for an actor as you drag it in the editor, or only when the drag operation is complete</summary>
	public bool bRunConstructionScriptOnDrag;
	///<summary>whether or not you want to continuously rerun the construction script for an actor in sequencer</summary>
	public bool bRunConstructionScriptInSequencer;
	///<summary>Whether or not this blueprint&#39;s class is a const class or not.  Should set CLASS_Const in the KismetCompiler.</summary>
	public bool bGenerateConstClass;
	///<summary>Whether or not this blueprint&#39;s class is a abstract class or not.  Should set CLASS_Abstract in the KismetCompiler.</summary>
	public bool bGenerateAbstractClass;
	///<summary>TRUE to show a warning when attempting to start in PIE and there is a compiler error on this Blueprint</summary>
	public bool bDisplayCompilePIEWarning;
	///<summary>Deprecates the Blueprint, marking the generated class with the CLASS_Deprecated flag</summary>
	public bool bDeprecate;
	///<summary>Flag indicating that a read only duplicate of this blueprint is being created, used to disable logic in ::PostDuplicate,</summary>
	public bool bDuplicatingReadOnly;
	///<summary>Whether to include the property GUIDs for the generated class in a cooked build.</summary>
	public EShouldCookBlueprintPropertyGuids ShouldCookPropertyGuidsValue;
	///<summary>NativizationFlag</summary>
	public EBlueprintNativizationFlag NativizationFlag;
	///<summary>The mode that will be used when compiling this class.</summary>
	public EBlueprintCompileMode CompileMode;
	///<summary>The current status of this blueprint</summary>
	public EBlueprintStatus Status;
	///<summary>Overrides the BP&#39;s display name in the editor UI</summary>
	public string BlueprintDisplayName;
	///<summary>Shows up in the content browser tooltip when the blueprint is hovered</summary>
	public string BlueprintDescription;
	///<summary>The namespace of this blueprint (if set, the Blueprint will be treated differently for the context menu)</summary>
	public string BlueprintNamespace;
	///<summary>The category of the Blueprint, used to organize this Blueprint class when displayed in palette windows</summary>
	public string BlueprintCategory;
	///<summary>Additional HideCategories. These are added to HideCategories from parent.</summary>
	public TArray<string> HideCategories;
	///<summary>The version of the blueprint system that was used to  create this blueprint</summary>
	public int BlueprintSystemVersion;
	///<summary>&#39;Simple&#39; construction script - graph of components to instance</summary>
	public USimpleConstructionScript SimpleConstructionScript;
	///<summary>Set of pages that combine into a single uber-graph</summary>
	public TArray<UEdGraph> UbergraphPages;
	///<summary>Set of functions implemented for this class graphically</summary>
	public TArray<UEdGraph> FunctionGraphs;
	///<summary>Graphs of signatures for delegates</summary>
	public TArray<UEdGraph> DelegateSignatureGraphs;
	///<summary>Set of macros implemented for this class</summary>
	public TArray<UEdGraph> MacroGraphs;
	///<summary>Set of functions actually compiled for this class</summary>
	public TArray<UEdGraph> IntermediateGeneratedGraphs;
	///<summary>Set of functions actually compiled for this class</summary>
	public TArray<UEdGraph> EventGraphs;
	///<summary>Cached cosmetic information about macro graphs, use GetCosmeticInfoForMacro() to access</summary>
	public TMap<UEdGraph,FBlueprintMacroCosmeticInfo> PRIVATE_CachedMacroInfo;
	///<summary>Array of component template objects, used by AddComponent function</summary>
	public TArray<UActorComponent> ComponentTemplates;
	///<summary>Array of templates for timelines that should be created</summary>
	public TArray<UTimelineTemplate> Timelines;
	///<summary>Array of blueprint overrides of component classes in parent classes</summary>
	public TArray<FBPComponentClassOverride> ComponentClassOverrides;
	///<summary>Stores data to override (in children classes) components (created by SCS) from parent classes</summary>
	public UInheritableComponentHandler InheritableComponentHandler;
	///<summary>Array of new variables to be added to generated class</summary>
	public TArray<FBPVariableDescription> NewVariables;
	///<summary>Array of user sorted categories</summary>
	public TArray<FName> CategorySorting;
	///<summary>Namespaces imported by this blueprint</summary>
	public TSet<string> ImportedNamespaces;
	///<summary>Array of info about the interfaces we implement in this blueprint</summary>
	public TArray<FBPInterfaceDescription> ImplementedInterfaces;
	///<summary>Set of documents that were being edited in this blueprint, so we can open them right away</summary>
	public TArray<FEditedDocumentInfo> LastEditedDocuments;
	///<summary>Bookmark data</summary>
	public TMap<FGuid,FEditedDocumentInfo> Bookmarks;
	///<summary>Bookmark nodes (for display)</summary>
	public TArray<FBPEditorBookmarkNode> BookmarkNodes;
	///<summary>moved to FPerBlueprintSettings</summary>
	public TArray<UDEPRECATED_Breakpoint> Breakpoints_DEPRECATED;
	///<summary>moved to FPerBlueprintSettings</summary>
	public TArray<FEdGraphPinReference> WatchedPins_DEPRECATED;
	///<summary>DeprecatedPinWatches</summary>
	public TArray<UEdGraphPin_Deprecated> DeprecatedPinWatches;
	///<summary>Index map for component template names</summary>
	public TMap<FName,int> ComponentTemplateNameIndex;
	///<summary>Maps old to new component template names</summary>
	public TMap<FName,FName> OldToNewComponentTemplateNames;
	///<summary>Extensions</summary>
	public TArray<UBlueprintExtension> Extensions;
	///<summary>Information for thumbnail rendering</summary>
	public UThumbnailInfo ThumbnailInfo;
	///<summary>CRC for CDO calculated right after the latest compilation used by Reinstancer to check if default values were changed</summary>
	public uint CrcLastCompiledCDO;
	///<summary>CrcLastCompiledSignature</summary>
	public uint CrcLastCompiledSignature;
	///<summary>Transient flag that indicates whether or not the internal dependency</summary>
	public bool bCachedDependenciesUpToDate;
	///<summary>Set of blueprints that we reference - i.e. blueprints that we have</summary>
	public TSet<TWeakObjectPtr<UBlueprint>> CachedDependencies;
	///<summary>Transient cache of dependent blueprints - i.e. blueprints that call</summary>
	public TSet<TWeakObjectPtr<UBlueprint>> CachedDependents;
	///<summary>User Defined Structures the blueprint depends on</summary>
	public TSet<TWeakObjectPtr<UStruct>> CachedUDSDependencies;
	///<summary>If this BP is just a duplicate created for a specific compilation, the reference to original GeneratedClass is needed</summary>
	public UClass OriginalClass;
}
