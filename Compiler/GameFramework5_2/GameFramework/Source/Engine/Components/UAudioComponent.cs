namespace GameFramework;
using CSharpToCpp.Utilities;
///<summary>AudioComponent is used to play a Sound</summary>
[CppInclude("Components/AudioComponent.h")]
public partial class UAudioComponent : USceneComponent {
	public static UClass StaticClass() {return default;}
	///<summary>The sound to be played</summary>
	public USoundBase Sound;
	///<summary>Array of parameters for this AudioComponent. Changes to this array directly will</summary>
	public TArray<FAudioParameter> DefaultParameters;
	///<summary>Array of transient parameters for this AudioComponent instance. Not serialized and can be set by code or BP.</summary>
	public TArray<FAudioParameter> InstanceParameters;
	///<summary>SoundClass that overrides that set on the referenced SoundBase when component is played.</summary>
	public USoundClass SoundClassOverride;
	///<summary>Auto destroy this component on completion</summary>
	public bool bAutoDestroy;
	///<summary>Stop sound when owner is destroyed</summary>
	public bool bStopWhenOwnerDestroyed;
	///<summary>Whether the wave instances should remain active if they&#39;re dropped by the prioritization code. Useful for e.g. vehicle sounds that shouldn&#39;t cut out.</summary>
	public bool bShouldRemainActiveIfDropped;
	///<summary>Overrides spatialization enablement in either the attenuation asset or on this audio component&#39;s attenuation settings override.</summary>
	public bool bAllowSpatialization;
	///<summary>Allows defining attenuation settings directly on this audio component without using an attenuation settings asset.</summary>
	public bool bOverrideAttenuation;
	///<summary>Whether or not to override the sound&#39;s subtitle priority.</summary>
	public bool bOverrideSubtitlePriority;
	///<summary>Whether or not this sound plays when the game is paused in the UI</summary>
	public bool bIsUISound;
	///<summary>Whether or not to apply a low-pass filter to the sound that plays in this audio component.</summary>
	public bool bEnableLowPassFilter;
	///<summary>Whether or not to override the priority of the given sound with the value provided.</summary>
	public bool bOverridePriority;
	///<summary>If true, subtitles in the sound data will be ignored.</summary>
	public bool bSuppressSubtitles;
	///<summary>If true, the Audio Component will play multiple sound instances at once. Switching sounds or calling play while already playing</summary>
	public bool bCanPlayMultipleInstances;
	///<summary>If true, the Audio Component will ignore parameter updates for already-playing sound(s).</summary>
	public bool bDisableParameterUpdatesWhilePlaying;
	///<summary>True if we should automatically attach to AutoAttachParent when Played, and detach from our parent when playback is completed.</summary>
	public bool bAutoManageAttachment;
	///<summary>Configurable, serialized ID for audio plugins</summary>
	public string AudioComponentUserID;
	///<summary>The lower bound to use when randomly determining a pitch multiplier</summary>
	public float PitchModulationMin;
	///<summary>The upper bound to use when randomly determining a pitch multiplier</summary>
	public float PitchModulationMax;
	///<summary>The lower bound to use when randomly determining a volume multiplier</summary>
	public float VolumeModulationMin;
	///<summary>The upper bound to use when randomly determining a volume multiplier</summary>
	public float VolumeModulationMax;
	///<summary>A volume multiplier to apply to sounds generated by this component</summary>
	public float VolumeMultiplier;
	///<summary>The attack time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the</summary>
	public int EnvelopeFollowerAttackTime;
	///<summary>The release time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the</summary>
	public int EnvelopeFollowerReleaseTime;
	///<summary>If enabled, overrides the priority of the selected sound with the value provided.</summary>
	public float Priority;
	///<summary>Used by the subtitle manager to prioritize subtitles wave instances spawned by this component.</summary>
	public float SubtitlePriority;
	///<summary>The chain of Source Effects to apply to the sounds playing on the Audio Component</summary>
	public USoundEffectSourcePresetChain SourceEffectChain;
	///<summary>VolumeWeightedPriorityScale_DEPRECATED</summary>
	public float VolumeWeightedPriorityScale_DEPRECATED;
	///<summary>HighFrequencyGainMultiplier_DEPRECATED</summary>
	public float HighFrequencyGainMultiplier_DEPRECATED;
	///<summary>A pitch multiplier to apply to sounds generated by this component</summary>
	public float PitchMultiplier;
	///<summary>If enabled, the frequency of the Lowpass Filter (in Hz) to apply to this voice. A frequency of 0.0 is the device sample rate and will bypass the filter.</summary>
	public float LowPassFilterFrequency;
	///<summary>If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component</summary>
	public USoundAttenuation AttenuationSettings;
	///<summary>If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component</summary>
	public FSoundAttenuationSettings AttenuationOverrides;
	///<summary>What sound concurrency to use for sounds generated by this audio component</summary>
	public USoundConcurrency ConcurrencySettings_DEPRECATED;
	///<summary>What sound concurrency rules to use for sounds generated by this audio component</summary>
	public TSet<USoundConcurrency> ConcurrencySet;
	///<summary>Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.</summary>
	public EAttachmentRule AutoAttachLocationRule;
	///<summary>Options for how we handle our rotation when we attach to the AutoAttachParent, if bAutoManageAttachment is true.</summary>
	public EAttachmentRule AutoAttachRotationRule;
	///<summary>Options for how we handle our scale when we attach to the AutoAttachParent, if bAutoManageAttachment is true.</summary>
	public EAttachmentRule AutoAttachScaleRule;
	///<summary>ModulationRouting</summary>
	public FSoundModulationDefaultRoutingSettings ModulationRouting;
	///<summary>This function returns the Targeted Audio Component&#39;s current Play State.</summary>
	public FOnAudioPlayStateChanged OnAudioPlayStateChanged;
	///<summary>Called when virtualization state changes</summary>
	public FOnAudioVirtualizationChanged OnAudioVirtualizationChanged;
	///<summary>Called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early</summary>
	public FOnAudioFinished OnAudioFinished;
	///<summary>Called as a sound plays on the audio component to allow BP to perform actions based on playback percentage.</summary>
	public FOnAudioPlaybackPercent OnAudioPlaybackPercent;
	///<summary>OnAudioSingleEnvelopeValue</summary>
	public FOnAudioSingleEnvelopeValue OnAudioSingleEnvelopeValue;
	///<summary>OnAudioMultiEnvelopeValue</summary>
	public FOnAudioMultiEnvelopeValue OnAudioMultiEnvelopeValue;
	///<summary>Called when subtitles are sent to the SubtitleManager.  Set this delegate if you want to hijack the subtitles for other purposes</summary>
	public FOnQueueSubtitles OnQueueSubtitles;
	///<summary>Set what sound is played by this component</summary>
	public void SetSound(USoundBase NewSound) {}
	///<summary>This function allows designers to call Play on an Audio Component instance while applying a volume curve over time.</summary>
	public virtual void FadeIn(float FadeInDuration,float FadeVolumeLevel/*=1.0f*/,float StartTime/*=0.0f*/,EAudioFaderCurve FadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>This function allows designers to call a delayed Stop on an Audio Component instance while applying a</summary>
	public virtual void FadeOut(float FadeOutDuration,float FadeVolumeLevel,EAudioFaderCurve FadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>Begins playing the targeted Audio Component&#39;s sound at the designated Start Time, seeking into a sound.</summary>
	public virtual void Play(float StartTime/*=0.0f*/) {}
	///<summary>Start a sound playing on an audio component on a given quantization boundary with the handle to an existing clock</summary>
	public virtual void PlayQuantized(UObject WorldContextObject,UQuartzClockHandle InClockHandle,FQuartzQuantizationBoundary InQuantizationBoundary,FOnQuartzCommandEventBP InDelegate,float InStartTime/*=0.0f*/,float InFadeInDuration/*=0.0f*/,float InFadeVolumeLevel/*=1.0f*/,EAudioFaderCurve InFadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>Sets a named Boolean</summary>
	public virtual void SetBoolParameter(string InName,bool InBool) {}
	///<summary>Sets a named Int32</summary>
	public virtual void SetIntParameter(string InName,int InInt) {}
	///<summary>Sets a named Float</summary>
	public virtual void SetFloatParameter(string InName,float InFloat) {}
	///<summary>Stop an audio component&#39;s sound, issue any delegates if needed</summary>
	public virtual void Stop() {}
	///<summary>Cues request to stop sound after the provided delay (in seconds), stopping immediately if delay is zero or negative</summary>
	public void StopDelayed(float DelayTime) {}
	///<summary>Pause an audio component playing its sound cue, issue any delegates if needed</summary>
	public void SetPaused(bool bPause) {}
	///<summary>Returns TRUE if the targeted Audio Component’s sound is playing.</summary>
	public virtual bool IsPlaying() { return default; }
	///<summary>Returns if the sound is virtualized.</summary>
	public bool IsVirtualized() { return default; }
	///<summary>Returns the enumerated play states of the audio component.</summary>
	public EAudioComponentPlayState GetPlayState() { return default; }
	///<summary>This function allows designers to trigger an adjustment to the sound instance’s playback Volume with options for smoothly applying a curve over time.</summary>
	public void AdjustVolume(float AdjustVolumeDuration,float AdjustVolumeLevel,EAudioFaderCurve FadeCurve/*=EAudioFaderCurve.Linear*/) {}
	///<summary>Sets the parameter matching the name indicated to the provided Wave. Provided for convenience/backward compatibility</summary>
	public void SetWaveParameter(string InName,USoundWave InWave) {}
	///<summary>Set a new volume multiplier</summary>
	public void SetVolumeMultiplier(float NewVolumeMultiplier) {}
	///<summary>Set a new pitch multiplier</summary>
	public void SetPitchMultiplier(float NewPitchMultiplier) {}
	///<summary>Set whether sounds generated by this audio component should be considered UI sounds</summary>
	public void SetUISound(bool bInUISound) {}
	///<summary>This function is used to modify the Attenuation Settings on the targeted Audio Component instance. It is worth noting that Attenuation Settings are only passed to new Active Sounds on start, so modified Attenuation data should be set before sound playback.</summary>
	public void AdjustAttenuation(FSoundAttenuationSettings InAttenuationSettings) {}
	///<summary>Allows designers to target a specific Audio Component instance’s sound set the send level (volume of sound copied) to the indicated Submix.</summary>
	public void SetSubmixSend(USoundSubmixBase Submix,float SendLevel) {}
	///<summary>Allows designers to target a specific Audio Component instance’s sound and set the send level (volume of sound copied)</summary>
	public void SetSourceBusSendPreEffect(USoundSourceBus SoundSourceBus,float SourceBusSendLevel) {}
	///<summary>Allows designers to target a specific Audio Component instance’s sound and set the send level (volume of sound copied)</summary>
	public void SetSourceBusSendPostEffect(USoundSourceBus SoundSourceBus,float SourceBusSendLevel) {}
	///<summary>Sets how much audio the sound should send to the given Audio Bus (PRE Source Effects).</summary>
	public void SetAudioBusSendPreEffect(UAudioBus AudioBus,float AudioBusSendLevel) {}
	///<summary>Sets how much audio the sound should send to the given Audio Bus (POST Source Effects).</summary>
	public void SetAudioBusSendPostEffect(UAudioBus AudioBus,float AudioBusSendLevel) {}
	///<summary>When set to TRUE, enables an additional Low Pass Filter Frequency to be calculated in with the</summary>
	public void SetLowPassFilterEnabled(bool InLowPassFilterEnabled) {}
	///<summary>Sets a cutoff frequency, in Hz, for the targeted Audio Component’s sound’s Low Pass Filter calculation.</summary>
	public void SetLowPassFilterFrequency(float InLowPassFilterFrequency) {}
	///<summary>Sets whether or not to output the audio to bus only.</summary>
	public void SetOutputToBusOnly(bool bInOutputToBusOnly) {}
	///<summary>Queries if the sound wave playing in this audio component has cooked FFT data, returns FALSE if none found.</summary>
	public bool HasCookedFFTData() { return default; }
	///<summary>Queries whether or not the targeted Audio Component instance’s sound has Amplitude Envelope Data, returns FALSE if none found.</summary>
	public bool HasCookedAmplitudeEnvelopeData() { return default; }
	///<summary>Retrieves the current-time cooked spectral data of the sounds playing on the audio component.</summary>
	public bool GetCookedFFTData(TArray<float> FrequenciesToGet,TArray<FSoundWaveSpectralData> OutSoundWaveSpectralData) { return default; }
	///<summary>Retrieves the current-time cooked spectral data of the sounds playing on the audio component.</summary>
	public bool GetCookedFFTDataForAllPlayingSounds(TArray<FSoundWaveSpectralDataPerSound> OutSoundWaveSpectralData) { return default; }
	///<summary>Retrieves Cooked Amplitude Envelope Data at the current playback time. If there are multiple</summary>
	public bool GetCookedEnvelopeData(float OutEnvelopeData) { return default; }
	///<summary>Retrieves the current-time amplitude envelope data of the sounds playing on the audio component.</summary>
	public bool GetCookedEnvelopeDataForAllPlayingSounds(TArray<FSoundWaveEnvelopeDataPerSound> OutEnvelopeData) { return default; }
	///<summary>Sets the routing for one of the given Audio component&#39;s Modulation Destinations.</summary>
	public void SetModulationRouting(TSet<USoundModulatorBase> Modulators,EModulationDestination Destination,EModulationRouting RoutingMethod/*=EModulationRouting.Inherit*/) {}
	///<summary>Gets the set of currently active modulators for a given Modulation Destination.</summary>
	public TSet<USoundModulatorBase> GetModulators(EModulationDestination Destination) { return default; }
	///<summary>Retrieves Attenuation Settings data on the targeted Audio Component. Returns FALSE if no settings were found.</summary>
	public bool BP_GetAttenuationSettingsToApply(FSoundAttenuationSettings OutAttenuationSettings) { return default; }
	///<summary>Component we automatically attach to when activated, if bAutoManageAttachment is true.</summary>
	public TWeakObjectPtr<USceneComponent> AutoAttachParent;
	///<summary>Socket we automatically attach to on the AutoAttachParent, if bAutoManageAttachment is true.</summary>
	public string AutoAttachSocketName;
}
